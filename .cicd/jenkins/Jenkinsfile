node {
    stage('Prepare') {
        git_checkout()
        setup_environment_variables()
        verify_tools()
        clean_test_resource() // in case previous job can't clean
    }

    stage('Test #1 (Sonarqube)') {
        sonarqube_check_code_quality()
    }

    stage('Test #2 (Odoo Pylint)') {
        build_pylint()
        pylint_test()
        clean_test_resource() // clean them for the next build and test
    }

    stage('Test #3 (Odoo Test cases)') {
        build()
        unit_test()
        clean_test_resource()
        integration_test()
    }

    stage('Deploy to server') {
        deploy_to_server()
    }
}

def setup_environment_variables() {
    env.CICD_PATH = "${env.WORKSPACE}/.cicd"
    env.PIPELINE_SCRIPTS_PATH = "${CICD_PATH}/jenkins/scripts"
    env.PIPELINE_UTILS_SCRIPT_PATH="${PIPELINE_SCRIPTS_PATH}/utils.sh"
    env.ODOO_IMAGE_TAG = "xmars/odoo16-cicd" // this valued mapped with odoo image name in odoo/docker-compose.yml file
    env.ODOO_WORKSPACE = "${CICD_PATH}/odoo"
    env.ODOO_CUSTOM_ADDONS_PATH = "${env.WORKSPACE}" // we put custom addons to top directory so other developers don't need to care about CICD config
    env.ODOO_DOCKER_COMPOSE_PATH = "${ODOO_WORKSPACE}"
    env.ODOO_DOCKER_COMPOSE_PROJECT_NAME = "odoo-${env.GIT_COMMIT}" // in case we run multiple pipeline, have to make sure each docker compose is separately
    env.CONFIG_FILE = "${ODOO_WORKSPACE}/etc/odoo.conf"
    env.LOG_FILE = "/var/log/odoo/odoo.log" // the log file is inside the odoo container
    env.LOG_FILE_OUTSIDE = "${ODOO_WORKSPACE}/logs/odoo.log" // mounted odoo's log file in Jenkins instance
}

def git_checkout() {
    if (is_pr_merged()){
        // TODO: do we need a different test process when code was merged to main repo 
        // like running test cases on existing database instead of empty database
        git_checkout_main_branch()
    }
    else {
        git_checkout_pull_request_branch()
    }
}

def git_checkout_main_branch() {
    // the branch that pull request is merge 'TO'
    echo "Checkout main branch!"
    checkout scmGit(branches: [
            [name: "origin/${pr_to_ref}"]
        ],
        extensions: [
            cloneOption(honorRefspec: true),
        ],
        userRemoteConfigs: [
            [credentialsId: 'github-ssh-cred', name: 'origin',
                refspec: '+refs/heads/*:refs/remotes/origin/*',
                url: "${pr_to_repo_ssh_url}"
            ]
        ])
}

def git_checkout_pull_request_branch() {
    // the branch that pull request is merge 'FROM'
    echo "Checkout pull request branch!"
    checkout scmGit(branches: [
            [name: "origin/pr/${pr_id}"]
        ],
        extensions: [
            cloneOption(honorRefspec: true),
        ],
        userRemoteConfigs: [
            [credentialsId: 'github-ssh-cred', name: 'origin',
                refspec: '+refs/pull/*/head:refs/remotes/origin/pr/* +refs/heads/*:refs/remotes/origin/*',
                url: "${pr_to_repo_ssh_url}"
            ]
        ])
}

def verify_tools() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/verify.sh > /dev/null", returnStatus: true)
    if (result != 0) {
        // missing required tools, stop pipeline immediately
        sh "exit $result"
    }
}

def build() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/build.sh false", returnStatus: true)
    if (result != 0) {
        clean_test_resource()
        sh "exit $result"
    }
}

def build_pylint() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/build.sh true", returnStatus: true)
}

def sonarqube_check_code_quality() {
    withCredentials([usernamePassword(credentialsId: 'sonar-cred', usernameVariable: 'SONAR_URL', passwordVariable: 'SONAR_TOKEN')]) {
        env.SONARQUBE_SCANNER_HOME = tool name: 'sonarqube-scanner', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
        def result_url=sh(script:"$PIPELINE_SCRIPTS_PATH/sonarqube.sh", returnStdout: true).trim()
        send_telegram_message("The code quality result of [PR \\#${pr_id}](${pr_url}) is [here]($result_url)")
    }
}

def pylint_test() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/pylint-test.sh", returnStatus: true);
    send_telegram_file(LOG_FILE_OUTSIDE, "The pylint test result for [PR \\#${pr_id}](${pr_url})\\!")
    // if (result != 0){
    //     send_telegram_file(LOG_FILE_OUTSIDE, "The pylint test result for [PR \\#${pr_id}](${pr_url})!")
    // }
}

def unit_test() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/unit-test.sh", returnStatus: true)
    if (result != 0) {
        def git_commit_message = "The build failed, please re-check the code!"
        set_github_commit_status("failure", git_commit_message);

        def telegram_message = """
The [PR \\#${pr_id}](${pr_url}) check has failed\\!
Please take a look at the attached log fileðŸ”¬
"""
        send_telegram_file(LOG_FILE_OUTSIDE, telegram_message)

        clean_test_resource()
        sh "exit $result"
    }
    set_github_commit_status("success", "The build succeed!");
}

def request_was_merged(){
    return pr_state == 'closed' && pr_merged == 'true'
}

def integration_test() {
    if (request_was_merged()) {
        // make a backup on server 
        def remote = prepare_remote_server_instance()
        def server_backup_script_folder = "/tmp/odoo/scripts"
        def server_backup_script_file = "$server_backup_script_folder/backup.sh"
        
        try {
            sshCommand remote: remote, command: "[ ! -d $server_backup_script_folder ] && mkdir -p $server_backup_script_folder"
            sshPut remote: remote, from: "$PIPELINE_SCRIPTS_PATH/server-backup.sh", into: server_backup_script_file
            sshCommand remote: remote, command: "chmod +x $server_backup_script_file"
            def remote_backup_file_path = sshCommand remote: remote, from: "$server_backup_script_file '$server_docker_compose_path' '$server_odoo_db_name' '$server_odoo_image_tag' '$server_backup_folder'"
            echo "$remote_backup_file_path"
        } catch (Exception e){
            echo "$e"
            // todo: send :can't backup error message to Telegram
            clean_test_resource()
            exit 1
        }
        
        // copy backup file to Jenkins
            // restore backup to new odoo instance
            // run all tests case on restored db
            // if error -> send message to telegram
    }
}

def is_pr_merged(){
    return pr_state == 'closed' && pr_merged == 'true'
}


def deploy_to_server() {
    if (is_pr_merged()) {
        def remote = prepare_remote_server_instance()
        withCredentials([
            file(credentialsId: 'remote-server-github-privatekey-cred',variable: 'server_github_privatekey_file')
        ]) {
            def git_private_key_folder_in_server = "~/.ssh/cicd"
            def git_private_key_file_in_server = "$git_private_key_folder_in_server/odoo-cicd-git-privkey"
            def server_deploy_script = "/tmp/odoo-cicd-deploy.sh"
            try {
                sshCommand remote: remote, command: "[ ! -d $git_private_key_folder_in_server ] && mkdir -p $git_private_key_folder_in_server", failOnError: false
                sshPut remote: remote, from: server_github_privatekey_file, into: git_private_key_file_in_server
                sshPut remote: remote, from: "$PIPELINE_SCRIPTS_PATH/deploy.sh", into: server_deploy_script
                sshCommand remote: remote, command: "chmod +x $server_deploy_script"
                sshCommand remote: remote, command: "$server_deploy_script '$server_docker_compose_path' '$server_custom_addons_path' '$server_config_file' '$git_private_key_file_in_server' '$server_odoo_url'"
                def success_message = "The [PR \\#${pr_id}](${pr_url}) was merged and deployed to server ðŸ’«ðŸ¤©ðŸ’«"
                send_telegram_message(success_message)
            } catch (Exception e) {
                echo "$e"
                def failed_message = """
The [PR \\#${pr_id}](${pr_url}) was merged but the deployment to the server failed\\!
Please take a look into [the build log]($BUILD_URL/console)\\.
"""
                send_telegram_message(failed_message)
            }
        }
    }
}

def prepare_remote_server_instance() {
    withCredentials([
        sshUserPrivateKey(credentialsId: 'remote-server-cred',
            keyFileVariable: 'server_privatekey',
            passphraseVariable: '',
            usernameVariable: 'server_username'),
        file(credentialsId: 'remote-server-github-privatekey-cred',
            variable: 'server_github_privatekey_file')
    ]) {
        def remote = [:]
        remote.name = "remote-server"
        remote.host = server_host
        remote.allowAnyHosts = true
        remote.user = server_username
        remote.identityFile = server_privatekey
        remote.fileTransfer = "scp"
        return remote
    }
}

def clean_test_resource() {
    sh "$PIPELINE_SCRIPTS_PATH/clean.sh"
}

def set_github_commit_status(String state, String message) {
    withCredentials([
        string(credentialsId: 'github-access-token-cred', variable: 'github_access_token')
    ]) {
        result = sh(script: "$PIPELINE_UTILS_SCRIPT_PATH exec set_github_commit_status_default '${state}' '${message}'", returnStdout: true).trim()
        if (result) {
            echo "$result"
        }
    }
}

def send_telegram_file(String file_path, String message) {
    // fixme: move temp-telegram-channel -> telegram-channel-id
    withCredentials([
        string(credentialsId: 'telegram-bot-token', variable: 'telegram_bot_token'),
        string(credentialsId: 'temp-telegram-channel', variable: 'telegram_channel_id')
    ]) {
        result = sh(script: "$PIPELINE_UTILS_SCRIPT_PATH exec send_file_telegram_default '${file_path}' '${message}'", returnStdout: true).trim()
        if (result) {
            echo "$result"
        }
    }
}

def send_telegram_message(String message) {
    // fixme: move temp-telegram-channel -> telegram-channel-id
    withCredentials([
        string(credentialsId: 'telegram-bot-token', variable: 'telegram_bot_token'),
        string(credentialsId: 'temp-telegram-channel', variable: 'telegram_channel_id')
    ]) {
        result = sh(script: "$PIPELINE_UTILS_SCRIPT_PATH exec send_message_telegram_default \"${message}\"", returnStdout: true).trim()
        if (result) {
            echo "$result"
        }
    }
}
