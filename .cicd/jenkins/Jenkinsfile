node {
    stage('Prepare') {
        git_checkout()
        setup_environment_variables()
        verify_tools()
    }

    // fixme: uncomment stage #1 & #2
    // stage('Test #1 (Sonarqube)') {
    //     sonarqube_check_code_quality()
    // }

    // stage('Test #2 (Odoo Pylint)') {
    //     build_pylint()
    //     pylint_test()
    //     clean_test_resource() // clean them for the next build and test
    // }

    stage('Test #3 (Odoo Test cases)') {
        // fixme: uncomment build and unit_test functions
        // build()
        // unit_test()
        integration_test()
        clean_test_resource()
    }

    // fixme: uncomment stage deploy
    // stage('Deploy to server') {
    //     deploy_to_server()
    // }
}

def setup_environment_variables() {
    env.CICD_PATH = "${env.WORKSPACE}/.cicd"
    env.PIPELINE_SCRIPTS_PATH = "${CICD_PATH}/jenkins/scripts"
    env.PIPELINE_UTILS_SCRIPT_PATH = "${PIPELINE_SCRIPTS_PATH}/utils.sh"
    env.ODOO_IMAGE_TAG = "xmars/odoo16-cicd" // this valued mapped with odoo image name in odoo/docker-compose.yml file
    env.ODOO_WORKSPACE = "${CICD_PATH}/odoo"
    env.ODOO_CUSTOM_ADDONS_PATH = "${env.WORKSPACE}" // we put custom addons to top directory so other developers don't need to care about CICD config
    env.ODOO_DOCKER_COMPOSE_PATH = "${ODOO_WORKSPACE}"
    env.ODOO_DOCKER_COMPOSE_PROJECT_NAME = "odoo-${pr_sha}" // in case we run multiple current jobs,we have to make sure each docker compose is separately
    env.ODOO_TEST_DATABASE_NAME = "test"
    env.CONFIG_FILE = "${ODOO_WORKSPACE}/etc/odoo.conf"
    env.LOG_FILE = "/var/log/odoo/odoo.log" // the log file is inside the odoo container
    env.LOG_FILE_OUTSIDE = "${ODOO_WORKSPACE}/logs/odoo.log" // mounted odoo's log file in Jenkins instance

    // backup file folder
    env.ODOO_TMP_BACKUP_FOLDER = "${env.WORKSPACE}/.tmp/server-backup"
}

def is_pr_merged() {
    // fixme: remove return true
    return true
    return pr_state == 'closed' && pr_merged == 'true'
}

def git_checkout() {
    if (is_pr_merged()) {
        // fixme:  remove  git_checkout_pull_request_branch() and uncomment git_checkout_main_branch()
        git_checkout_pull_request_branch()
        // git_checkout_main_branch()
    } else {
        git_checkout_pull_request_branch()
    }
}

def git_checkout_main_branch() {
    // the branch that pull request is merge 'TO'
    echo "Checkout main branch!"
    checkout scmGit(branches: [
            [name: "origin/${pr_to_ref}"]
        ],
        extensions: [
            cloneOption(honorRefspec: true),
        ],
        userRemoteConfigs: [
            [credentialsId: 'github-ssh-cred', name: 'origin',
                refspec: '+refs/heads/*:refs/remotes/origin/*',
                url: "${pr_to_repo_ssh_url}"
            ]
        ])
}

def git_checkout_pull_request_branch() {
    // the branch that pull request is merge 'FROM'
    echo "Checkout pull request branch!"
    checkout scmGit(branches: [
            [name: "origin/pr/${pr_id}"]
        ],
        extensions: [
            cloneOption(honorRefspec: true),
        ],
        userRemoteConfigs: [
            [credentialsId: 'github-ssh-cred', name: 'origin',
                refspec: '+refs/pull/*/head:refs/remotes/origin/pr/* +refs/heads/*:refs/remotes/origin/*',
                url: "${pr_to_repo_ssh_url}"
            ]
        ])
}

def verify_tools() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/verify.sh > /dev/null", returnStatus: true)
    if (result != 0) {
        // missing required tools, stop pipeline immediately
        sh "exit $result"
    }
}

def build() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/build.sh false", returnStatus: true)
    if (result != 0) {
        clean_test_resource()
        sh "exit $result"
    }
}

def build_pylint() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/build.sh true", returnStatus: true)
}

def sonarqube_check_code_quality() {
    withCredentials([usernamePassword(credentialsId: 'sonar-cred', usernameVariable: 'SONAR_URL', passwordVariable: 'SONAR_TOKEN')]) {
        env.SONARQUBE_SCANNER_HOME = tool name: 'sonarqube-scanner', type: 'hudson.plugins.sonar.SonarRunnerInstallation'
        def result_url = sh(script: "$PIPELINE_SCRIPTS_PATH/sonarqube.sh", returnStdout: true).trim()
        send_telegram_message("The code quality result of [PR \\#${pr_id}](${pr_url}) is [here]($result_url)")
    }
}

def pylint_test() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/pylint-test.sh", returnStatus: true);
    send_telegram_file(LOG_FILE_OUTSIDE, "The pylint test result for [PR \\#${pr_id}](${pr_url})\\!")
    // if (result != 0){
    //     send_telegram_file(LOG_FILE_OUTSIDE, "The pylint test result for [PR \\#${pr_id}](${pr_url})!")
    // }
}

def unit_test() {
    def result = sh(script: "$PIPELINE_SCRIPTS_PATH/unit-test.sh", returnStatus: true)
    if (result != 0) {
        def git_commit_message = "The build failed, please re-check the code!"
        set_github_commit_status("failure", git_commit_message);

        def telegram_message = """
The [PR \\#${pr_id}](${pr_url}) check has failed\\!
Please take a look at the attached log fileðŸ”¬
"""
        send_telegram_file(LOG_FILE_OUTSIDE, telegram_message)

        clean_test_resource()
        sh "exit $result"
    }
    set_github_commit_status("success", "The build succeed!");
}

def integration_test() {
    if (is_pr_merged()) {
        withCredentials([
            sshUserPrivateKey(credentialsId: 'remote-server-cred',
                keyFileVariable: 'server_privatekey',
                passphraseVariable: '',
                usernameVariable: 'server_username'),
            file(credentialsId: 'remote-server-github-privatekey-cred',
                variable: 'server_github_privatekey_file')
        ]) {
            def remote = [: ]
            remote.name = "remote-server"
            remote.host = server_host
            remote.allowAnyHosts = true
            remote.user = server_username
            remote.identityFile = server_privatekey
            remote.fileTransfer = "sftp"

            def server_backup_script_folder = "/tmp/odoo/scripts"
            def server_backup_script_file = "$server_backup_script_folder/backup.sh"
            def jenkin_backup_file_path = ""
            try {
                sshCommand remote: remote, command: "[ ! -d $server_backup_script_folder ] && mkdir -p $server_backup_script_folder || true"
                // sshPut remote: remote, from: "$PIPELINE_SCRIPTS_PATH/server-backup.sh", into: server_backup_script_file
                sshPut remote: remote, from: "$PIPELINE_SCRIPTS_PATH/server-backup.sh", into: server_backup_script_file
                sshCommand remote: remote, command: "chmod +x $server_backup_script_file"
                remote_backup_file_path = sshCommand remote: remote, command: "$server_backup_script_file '$server_docker_compose_path' '$server_odoo_db_name' '$server_odoo_image_tag'"
                sh "rm -rf ${ODOO_TMP_BACKUP_FOLDER}/* && mkdir -p $ODOO_TMP_BACKUP_FOLDER || true"
                def jenkin_backup_file_name = sh(script: "basename $remote_backup_file_path", returnStdout: true).trim()
                jenkin_backup_file_path = "${ODOO_TMP_BACKUP_FOLDER}/${jenkin_backup_file_name}"
                sshGet remote: remote, from: remote_backup_file_path, into: env.ODOO_TMP_BACKUP_FOLDER, override: true
            } catch (Exception e) {
                echo "$e"
            }

            if (!jenkin_backup_file_path){
                def failed_message = """
Cannot take a backup from remote server to continue testing process\\.
Please take a look into [the build log](${BUILD_URL}console) ðŸ”¬                
"""
                send_message_telegram_default(failed_message)
                clean_test_resource()
                sh "exit 1"
            }
            def result = sh(script: "$PIPELINE_SCRIPTS_PATH/integration-test.sh $jenkin_backup_file_path", returnStatus: true)
            echo "integration tst result here : $result"

            // todo
            // copy backup file to Jenkins.
            // restore backup to new odoo instance
            // run all tests case on restored db
            // if error -> send message to telegram
        }
    }
}

def deploy_to_server() {
    if (is_pr_merged()) {
        withCredentials([
            sshUserPrivateKey(credentialsId: 'remote-server-cred',
                keyFileVariable: 'server_privatekey',
                passphraseVariable: '',
                usernameVariable: 'server_username'),
            file(credentialsId: 'remote-server-github-privatekey-cred',
                variable: 'server_github_privatekey_file')
        ]) {
            def remote = [: ]
            remote.name = "remote-server"
            remote.host = server_host
            remote.allowAnyHosts = true
            remote.user = server_username
            remote.identityFile = server_privatekey
            remote.fileTransfer = "scp"

            def git_private_key_folder_in_server = "~/.ssh/cicd"
            def git_private_key_file_in_server = "$git_private_key_folder_in_server/odoo-cicd-git-privkey"
            def server_deploy_script = "/tmp/odoo-cicd-deploy.sh"
            try {
                sshCommand remote: remote, command: "[ ! -d $git_private_key_folder_in_server ] && mkdir -p $git_private_key_folder_in_server || true"
                sshPut remote: remote, from: server_github_privatekey_file, into: git_private_key_file_in_server
                sshPut remote: remote, from: "$PIPELINE_SCRIPTS_PATH/deploy.sh", into: server_deploy_script
                sshCommand remote: remote, command: "chmod +x $server_deploy_script"
                sshCommand remote: remote, command: "$server_deploy_script '$server_docker_compose_path' '$server_custom_addons_path' '$server_config_file' '$git_private_key_file_in_server' '$server_odoo_url'"
                def success_message = "The [PR \\#${pr_id}](${pr_url}) was merged and deployed to server ðŸ’«ðŸ¤©ðŸ’«"
                send_telegram_message(success_message)
            } catch (Exception e) {
                echo "$e"
                def failed_message = """
The [PR \\#${pr_id}](${pr_url}) was merged but the deployment to the server failed\\!
Please take a look into [the build log](${BUILD_URL}console)\\.
"""
                send_telegram_message(failed_message)
            }

        }
    }
}

def clean_test_resource() {
    sh "$PIPELINE_SCRIPTS_PATH/clean.sh"
}

def set_github_commit_status(String state, String message) {
    withCredentials([
        string(credentialsId: 'github-access-token-cred', variable: 'github_access_token')
    ]) {
        result = sh(script: "$PIPELINE_UTILS_SCRIPT_PATH exec set_github_commit_status_default '${state}' '${message}'", returnStdout: true).trim()
        if (result) {
            echo "$result"
        }
    }
}

def send_telegram_file(String file_path, String message) {
    // fixme: move temp-telegram-channel -> telegram-channel-id
    withCredentials([
        string(credentialsId: 'telegram-bot-token', variable: 'telegram_bot_token'),
        string(credentialsId: 'temp-telegram-channel', variable: 'telegram_channel_id')
    ]) {
        result = sh(script: "$PIPELINE_UTILS_SCRIPT_PATH exec send_file_telegram_default '${file_path}' '${message}'", returnStdout: true).trim()
        if (result) {
            echo "$result"
        }
    }
}

def send_telegram_message(String message) {
    // fixme: move temp-telegram-channel -> telegram-channel-id
    withCredentials([
        string(credentialsId: 'telegram-bot-token', variable: 'telegram_bot_token'),
        string(credentialsId: 'temp-telegram-channel', variable: 'telegram_channel_id')
    ]) {
        result = sh(script: "$PIPELINE_UTILS_SCRIPT_PATH exec send_message_telegram_default \"${message}\"", returnStdout: true).trim()
        if (result) {
            echo "$result"
        }
    }
}